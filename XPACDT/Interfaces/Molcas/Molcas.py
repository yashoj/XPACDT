import numpy as np
import os
import subprocess

from datetime import date
from io import StringIO
from pathlib import Path

from XPACDT.Interfaces.InterfaceTemplate import PotentialInterface
from XPACDT.Interfaces.Molcas.Patterns import PATTERNS
from XPACDT.Tools.XYZ import format_xyz, parse_xyz


class MolcasError(Exception):
    """Error related to MOLCAS."""

    # TODO Write verbose output to file rather than STDERR
    def __init__(self, molcas_output):
        groups = PATTERNS["error"].findall(molcas_output)
        if len(groups) == 0:
            super().__init__(
                f"""MOLCAS error of unknown nature.
                Here is the full MOLCAS output for reference

                {molcas_output}""")

        else:
            section, err = groups[-1]

            super().__init__(
                f"""The following MOLCAS error occured

                {err}

                The output of the corresponding section is given below

                {section}
                """)


class Molcas(PotentialInterface):
    """
    Electronic structure as computed by the external program MOLCAS.

    A fresh envrionnement is created to run MOLCAS, to avoid contamination
    of system variables from the outside scope. The PATH variable is the only
    one kept. Also the MOLCAS rc file is ignored.

    This means that MOLCAS can not be configured from the exterior of this
    program and that everything related to the configuration is retrieved
    from the input file.

    The interface will create folders for MOLCAS files, which typically looks
    as follow:

    tmpdir/
      000001/       # Unique ID of one MolcasInterface instance
        output/
        workdir/
      000002/
        output/
        workdir/

    Parameters
    ----------
    n_dof : int
        Degrees of freedom.

    n_states : int
        Number of electronic states. Default: 1.

    max_n_beads : int, optional
        Maximum number of beads from the (n_dof) list of n_beads. Default: 1.

    tmpdir : path-like, optional
        Directory where the temporary files generated by MOLCAS will be put.
        Default: `./tmp/molcas_interface/{current_date}`

    molcas_executable : str, optional
        Name of the MOLCAS executable to use. Default: "molcas"

    basis : str
        Basis set for the computation (see MOLCAS manual for details).

    rasscf_filepath : path-like
        Path of the file containing the MOLCAS input file describing the
        RASSCF part of the computation.
    """
    # TODO lowercase everything in input file
    def __init__(self, Molcas=None, **global_parameters):
        super().__init__("Molcas",
                         primary_basis="adiabatic",
                         **global_parameters)

        print(global_parameters["n_beads"])
        print(dict(**global_parameters))

        if self.max_n_beads != 1:
            raise NotImplementedError(
                    "Beads not supported for Molcas interface yet "
                    f"(input gave max_n_beads = {self.max_n_beads}).")


        # TODO Move to template ? Use getter ?
        self.n_atoms = self.n_dof // 3
        self._atoms = ["H", "H"]

        # Use the current date in the MOLCAS project name and temporary dir
        # to have a clean ordering of files
        today = date.today().isoformat()
        if tmpdir is None:
            tmpdir = Path.cwd() / "tmp" / "molcas_interface" / today

        dirnames = sorted(tmpdir.glob("*/"), reverse=True)

        self._id = 1

        # Find the last folder in tmpdir and set the ID of the current instance
        for d in dirnames:
            try:
                self._id = int(str(d.name)) + 1
                break
            except ValueError:
                pass

        # ID of the instance is padded 0 to have a nice file ordering
        self._id_str = f"{self._id:06}"
        self._tmpdir = tmpdir / self._id_str

        self._workdir = self._tmpdir / "workdir"
        self._workdir.mkdir(parents=True, exist_ok=True)

        self._outputdir = self._tmpdir / "output"
        self._outputdir.mkdir(parents=True, exist_ok=True)

        # Create a clean environnement to run MOLCAS, only copying the PATH
        # variable from the calling environnement to avoid contamination of
        # the shell variable used by MOLCAS from the outside shell.
        # TODO Allow to give other related env variable in input ?
        # e.g. MOLCAS directory
        self._molcas_env = dict(
            PATH=os.environ["PATH"],
            MOLCAS_PROJECT=self._id_str,
            MOLCAS_WORKDIR=str(self._workdir),
            MOLCAS_OUTPUT=str(self._outputdir)
        )

        self._molcas_executable = molcas_executable
        self._test_molcas()

        self._nac_input_file = self._tmpdir / "nac_input.input"
        self._optim_input_file = self._tmpdir / "optim_input.input"
        self._xyz_file = self._tmpdir / "coordinates.xyz"

        # Find the template file relative to the current file
        nac_template = self._load_template("nac_template.input")
        optim_template = self._load_template("optim_template.input")
        self._xyz_template = self._load_template("template.xyz")

        rasscf = Path(rasscf_filepath).read_text()

        # Format the template with the parameters from the input file
        # This is constant thanks to the use of a separate file for coordinates
        nac_input = nac_template.format(
            basis=basis,
            n_states=n_states,
            rasscf=rasscf,
            xyz_file=self._xyz_file)

        self._nac_input_file.write_text(nac_input)

        optim_input = optim_template.format(
            basis=basis,
            xyz_file=self._xyz_file)

        self._optim_input_file.write_text(optim_input)

    def _calculate_adiabatic_all(self, R, S=None):
        self._write_xyz(R[:, 0])

        full_output = self._molcas_subprocess(self._nac_input_file)

        # Parse the energy of each RASSCF root
        energies = PATTERNS["energy"].findall(full_output)
        energies = list(map(float, energies[:self.n_states]))
        self._adiabatic_energy[:, 0] = np.array(energies)

        # Parse the molecular gradient at each nucleus
        gradient_section, = PATTERNS["gradient section"].findall(full_output)
        gradients = PATTERNS["molecular vector"].findall(gradient_section)

        self._adiabatic_gradient[0, :, 0] = np.concatenate(
            [np.fromstring(grad, sep=" ") for grad in gradients])

        # Parse the NAC for each pair of states
        nac_sections = PATTERNS["nac section"].findall(full_output)
        section_num = 0

        for i in range(self.n_states):
            for j in range(i):
                nac_section = nac_sections[section_num]
                matched_vec = PATTERNS["molecular vector"].findall(nac_section)
                nac_vector = np.concatenate(
                    [np.fromstring(v, sep=" ") for v in matched_vec])

                self._nac[i, j, :, 0] = nac_vector
                self._nac[j, i, :, 0] = -nac_vector

                section_num += 1

    def _load_template(self, template_name):
        return self._template_path(template_name).read_text()

    def _molcas_subprocess(self, *args):
        """
        Start MOLCAS as a subprocess and return its output as a string.

        Use a minimal environnement containing only the PATH variable
        and MOLCAS related shell variables defined based on the content of 
        the input file. Does not ignore MOLCAS .rc file.

        Parameters
        ----------
        *args : All parameters must be strings and are passed as additional
            parameters to the MOLCAS program.
        """
        try:
            res = subprocess.run(
                [self._molcas_executable, *args],
                env=self._molcas_env,  # Define environnement variables
                text=True,  # Everything treated as string rather than binary
                stdout=subprocess.PIPE,  # Redirect output
                stderr=subprocess.PIPE)
        except FileNotFoundError:
            raise FileNotFoundError(
                f"No MOLCAS executable named {self._molcas_executable} found. "
                "Make sure to add the executable to your PATH or to specify "
                "its full path in the input file.")

        # Raise an error if something wrong happened within MOLCAS
        if res.returncode != 0:
            raise MolcasError(res.stdout)

        # Molcas creates a $Project.status file that is not redirected to
        # either the workdir or the outputdir, so we move it manually
        # TODO Open a ticket about it on Molcas support
        status_file = Path(f"{self._id_str}.status")

        if status_file.is_file():
            status_file.replace(self._tmpdir / ".status")

        return res.stdout

    def _optimize_geometry(self, R):
        self._write_xyz(R[:, 0])
        self._molcas_subprocess("-new", self._optim_input_file)

        xyz_file = self._outputdir / f"{self._id_str}.Opt.xyz"
        _, coord = parse_xyz(filename=xyz_file)
        coord = np.hstack(coord)
        # TODO Collect hessian
        return coord

    def _template_path(self, template_name):
        local_dir = Path(__file__).parent.resolve()
        return local_dir / template_name

    def _test_molcas(self):
        """
        Test that the molcas executable name exists and that it's version is
        supported (currently 8.2 or later).
        """
        empty_input = self._template_path("empty.input")

        # Run molcas with empty input file to only have base output
        output = self._molcas_subprocess(empty_input)
        version_info, = PATTERNS["molcas version"].findall(output)
        version, major, minor = version_info
        major = int(major)
        minor = int(minor)

        # TODO Move this to some kind of logging system
        # TODO Add more log info (project name, tmp dir)
        print(f"MOLCAS version {version} is used.")

        if major < 8 or (major == 8 and minor < 2):
            raise RuntimeError(f"XPACDT only support Molcas 8.2 or later, "
                               f"but was started with Molcas {version}")

    def _write_xyz(self, r):
        """
        Write the XYZ file corresponding to the given nuclei positions.

        Parameters
        ----------
        r : (n_dof,) ndarray of floats
            Nuclei positions
        """
        self._xyz_file.write_text(format_xyz(self._atoms, r))
