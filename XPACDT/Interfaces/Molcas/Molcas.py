import numpy as np
import os
import subprocess

from datetime import datetime
from pathlib import Path

from XPACDT.Interfaces.InterfaceTemplate import PotentialInterface
from XPACDT.Interfaces.Molcas.Patterns import PATTERNS


class MolcasError(Exception):
    """Error related to MOLCAS."""

    # TODO Write verbose output to file rather than STDERR
    def __init__(self, molcas_output):
        groups = PATTERNS["error"].findall(molcas_output)
        if len(groups) == 0:
            super().__init__(
                f"""MOLCAS error of unknown nature.
                Here is the full MOLCAS output for reference

                {molcas_output}""")

        else:
            section, err = groups[-1]

            super().__init__(
                f"""The following MOLCAS error occured

                {err}

                The output of the corresponding section is given below

                {section}
                """)


class Molcas(PotentialInterface):
    """
    Electronic structure as computed by the external program MOLCAS.

    A fresh envrionnement is created to run MOLCAS, to avoid contamination
    of system variables from the outside scope. The PATH variable is the only
    one kept. Also the MOLCAS rc file is ignored.

    This means that MOLCAS can not be configured from the exterior of this
    program and that everything related to the configuration is retrieved
    from the input file.

    Parameters
    ----------
    n_dof : int
        Degrees of freedom.

    n_states : int
        Number of electronic states. Default: 1.

    max_n_beads : int, optional
        Maximum number of beads from the (n_dof) list of n_beads. Default: 1.

    workdir : path-like, optional
        Directory where the temporary files generated by MOLCAS will be put.
        Default: `./tmp/molcas/XPACDT_project_{date and time}/workdir`

    outputdir : path-like, optional
        Directory where the output files generated by MOLCAS will be put.
        Default: `./tmp/molcas/XPACDT_project_{date and time}/output`

    molcas_executable : str, optional
        Name of the MOLCAS executable to use. Default: "molcas"

    basis : str
        Basis set for the computation (see MOLCAS manual for details).

    rasscf_filepath : path-like
        Path of the file containing the MOLCAS input file describing the
        RASSCF part of the computation.
    """
    def __init__(self,
                 max_n_beads=1,
                 n_dof=1,
                 n_states=1,
                 workdir=None,
                 outputdir=None,
                 molcas_executable="molcas",
                 basis="",
                 rasscf_filepath=Path(),
                 **kwargs):

        if max_n_beads != 1:
            raise NotImplementedError(
                    "Beads not supported for Molcas interface yet.")

        super().__init__("Molcas",
                         n_dof,
                         n_states,
                         max_n_beads,
                         "adiabatic")

        # TODO Move to template ? Use getter ?
        self.n_atoms = n_dof // 3

        # Use the current time in the MOLCAS project name for unicity and
        # to have a nice ordering of files
        time_desc = datetime.now().isoformat(timespec="seconds")
        project_name = f"XPACDT_project_{time_desc}"
        self._project_name = project_name

        tmpdir = Path.cwd() / "tmp" / "molcas" / project_name

        self._workdir = tmpdir / "workdir" if workdir is None else workdir
        self._workdir.mkdir(parents=True, exist_ok=True)

        self._outputdir = tmpdir / "output" if outputdir is None else outputdir
        self._outputdir.mkdir(parents=True, exist_ok=True)

        # Create a clean environnement to run MOLCAS, only copying the PATH
        # variable from the calling environnement to avoid contamination of
        # the shell variable used by MOLCAS from the outside shell.
        # TODO Allow to give other related env variable in input ?
        # e.g. MOLCAS directory
        self._molcas_env = dict(
            PATH=os.environ["PATH"],
            MOLCAS_PROJECT=project_name,
            MOLCAS_WORKDIR=str(self._workdir),
            MOLCAS_OUTPUT=str(self._outputdir),
            MOLCAS_NEW_WORKDIR="NO"
        )

        self._molcas_executable = molcas_executable
        self._test_molcas()

        # Wether to reuse result the orbitals of the previous iteration as
        # starting point for the new orbitals computations
        self._compute_from_scratch = True

        self._molcas_input_file = self._workdir / f"{project_name}.input"
        self._molcas_xyz_file = self._workdir / f"{project_name}.xyz"

        # Find the template file relative to the current file
        raw_input_template_file = Path(__file__).with_name("template.input")
        raw_input_template = raw_input_template_file.read_text()
        xyz_template_file = Path(__file__).with_name("template.xyz")
        self._xyz_template = xyz_template_file.read_text()

        rasscf = Path(rasscf_filepath).read_text()

        # Partially format the template with the parameters that stay constant
        molcas_input = raw_input_template.format(
            basis=basis,
            n_atoms=n_dof//3,
            n_states=n_states,
            rasscf=rasscf,
            xyz_file=str(self._molcas_xyz_file))

        self._molcas_input_file.write_text(molcas_input)

    def _calculate_adiabatic_all(self, R, P, S=0):
        # TODO Take the current state in account
        full_output = self._run_molcas(R)

        # Parse the energy of each RASSCF root
        energies = PATTERNS["energy"].findall(full_output)
        energies = list(map(float, energies[:self.n_states]))
        self._adiabatic_energy[:, 0] = np.array(energies)

        # Parse the molecular gradient at each nucleus
        gradient_section, = PATTERNS["gradient section"].findall(full_output)
        gradients = PATTERNS["molecular vector"].findall(gradient_section)

        self._adiabatic_gradient[0, :, 0] = np.concatenate(
            [np.fromstring(grad, sep=" ") for grad in gradients])

        # Parse the NAC for each pair of states
        nac_sections = PATTERNS["nac section"].findall(full_output)
        section_num = 0

        for i in range(self.n_states):
            for j in range(i):
                nac_section = nac_sections[section_num]
                matched_vec = PATTERNS["molecular vector"].findall(nac_section)
                nac_vector = np.concatenate(
                    [np.fromstring(v, sep=" ") for v in matched_vec])

                self._nac[i, j, :, 0] = nac_vector
                self._nac[j, i, :, 0] = -nac_vector

                section_num += 1

    def _molcas_subprocess(self, *args):
        """
        Start MOLCAS as a subprocess and return its output as a string.

        Ignore MOLCAS rc file (-ign option) and use a minimal environnement
        containing only the PATH variable and MOLCAS related shell variables
        defined based on the content of the input file.

        Parameters
        ----------
        *args : All parameters must be strings and are passed as additional
            parameters to the MOLCAS program.
        """
        try:
            res = subprocess.run(
                [self._molcas_executable, "-ign", *args],
                env=self._molcas_env,  # Define environnement variables
                text=True,  # Everything treated as string rather than binary
                stdout=subprocess.PIPE,  # Redirect output
                stderr=subprocess.PIPE)
        except FileNotFoundError:
            raise FileNotFoundError(
                f"No MOLCAS executable named {self._molcas_executable} found. "
                "Make sure to add the executable to your PATH or to specify "
                "its full path in the input file.")

        # Raise an error if something wrong happened within MOLCAS
        if res.returncode != 0:
            raise MolcasError(res.stdout)

        # Molcas creates a $Project.status file that is not redirected to
        # either the workdir or the outputdir, so we move it manually.
        # TODO Open a ticket about it on Molcas support
        status_file = Path(f"{self._project_name}.status")

        if status_file.is_file():
            status_file.replace(self._outputdir / ".status")

        return res.stdout

    def _run_molcas(self, R):
        """
        Run MOLCAS for a given configuration.
        """
        xyz_str = self._xyz_template.format(
            n_atoms=self.n_atoms,
            xyz=self._xyz(R[:, 0]))
        self._molcas_xyz_file.write_text(xyz_str)

        # NOTE Currently self._compute_from_scratch is always True
        if self._compute_from_scratch:
            self._molcas_env["MOLCAS_NEW_WORKDIR"] = "YES"
        else:
            self._molcas_env["MOLCAS_NEW_WORKDIR"] = "NO"

        return self._molcas_subprocess(self._molcas_input_file)

    def _test_molcas(self):
        """
        Test that the molcas executable name exists and determine its MOLCAS
        version.
        """
        empty_input = Path(__file__).with_name("empty.input")

        # Run molcas with empty input file to only have base output
        output = self._molcas_subprocess(empty_input)

        self._molcas_version, = PATTERNS["molcas version"].findall(output)

        # TODO Move this to some kind of logging system
        print(f"MOLCAS version {self._molcas_version} is used.")

        # TODO check if the provided MOLCAS supports Alaska NAC e.g. using molcas help alaska nac

    def _xyz(self, r):
        """
        Transform the given nuclear degrees of freedom `r` in a string in
        XYZ format.

        Parameters
        ----------
        r : (n_dof,) ndarraz of floats
            Nuclei positions
        """
        # TODO Use stored atom named once this is implemented
        # NOTE THis could be defined at the template level
        positions = r.reshape(self.n_atoms, 3)
        lines = [" ".join(["H", *map(str, pos)]) for pos in positions]
        return "\n".join(lines)
