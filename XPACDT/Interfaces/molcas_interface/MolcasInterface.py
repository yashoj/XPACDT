import numpy as np
import os
import subprocess

from datetime import datetime
from pathlib import Path

from XPACDT.Interfaces.InterfaceTemplate import PotentialInterface
from XPACDT.Interfaces.molcas_interface.Patterns import PATTERNS


class MolcasError(Exception):
    """Error related to MOLCAS."""

    # TODO Write verbose output to file rather than STDERR
    def __init__(self, molcas_output):
        groups = PATTERNS["error"].findall(molcas_output)
        if len(groups) == 0:
            super().__init__(
                f"""MOLCAS error of unknown nature.
                Here is the full MOLCAS output for reference

                {molcas_output}""")

        else:
            section, err = groups[-1]

            super().__init__(
                f"""The following MOLCAS error occured

                {err}

                The output of the corresponding section is given below

                {section}
                """)


class MolcasInterface(PotentialInterface):
    """
    Electronic structure as computed by the external program MOLCAS.

    A fresh envrionnement is created to run MOLCAS, to avoid contamination
    of system variables from the outside scope. The PATH variable is the only
    one kept. Also the MOLCAS rc file is ignored.

    This means that MOLCAS can not be configured from the exterior of this
    program and that everything related to the configuration is retrieved
    from the input file.

    Parameters
    ----------
    n_dof : int
        Degrees of freedom.

    n_states : int
        Number of electronic states. Default: 1.

    max_n_beads : int, optional
        Maximum number of beads from the (n_dof) list of n_beads. Default: 1.

    workdir : path-like, optional
        Directory where the temporary files generated by MOLCAS will be put.
        Default: `./tmp/molcas`

    molcas_executable : str, optional
        Name of the MOLCAS executable to use. Default: "molcas"

    basis : str
        Basis set for the computation (see MOLCAS manual for details).

    rasscf_filepath : path-like
        Path of the file containing the MOLCAS input file describing the
        RASSCF part of the computation.
    """
    def __init__(self,
                 n_dof=1,
                 n_states=1,
                 max_n_beads=1,
                 workdir=Path.cwd() / "tmp" / "molcas",
                 molcas_executable="molcas",
                 basis="",
                 rasscf_filepath=Path(),
                 **kwargs):

        if max_n_beads != 1:
            raise NotImplementedError(
                    "Beads not supported for Molcas interface yet.")

        super().__init__(self,
                         "Molcas",
                         n_dof,
                         n_states,
                         max_n_beads,
                         "adiabatic")

        # Use the current time in the MOLCAS project name for unicity and
        # to have a nice ordering of files
        time_desc = datetime.now().isoformat(timespec="seconds")
        molcas_project_name = f"XPACDT_project_{time_desc}"

        self._workdir = workdir
        self._workdir.mkdir(parents=True, exists_ok=True)

        # Create a clean environnement to run MOLCAS, only copying the PATH
        # variable from the calling environnement to avoid contamination of
        # the shell variable used by MOLCAS
        self._molcas_env = {}
        self._molcas_env["PATH"] = os.environ["PATH"]

        # Environnements variables used by MOLCAS
        # TODO Allow to give other related env variable in input ?
        # e.g. MOLCAS directory
        self._molcas_env["MOLCAS_PROJECT"] = molcas_project_name
        self._molcas_env["MOLCAS_WORKDIR"] = str(self._workdir)
        self._molcas_env["MOLCAS_NEW_WORKDIR"] = "NO"

        self._molcas_executable = molcas_executable
        self._test_molcas()

        # Wether to reuse result the orbitals of the previous iteration as
        # starting point for the new orbitals computations
        self._compute_from_scratch = True

        self._molcas_runfile = self._workdir / f"{molcas_project_name}.RunFile"
        self._molcas_input_file = self._molcas_runfile.with_suffix("input")

        # Find the template file relative to the current file
        raw_input_template_file = Path(__file__).with_name("template.input")
        raw_input_template = raw_input_template_file.read_text()

        rasscf = Path(rasscf_filepath).read_text()

        # Partially format the template with the parameters that stay constant
        self._template_molcas_input = raw_input_template.format(
            basis=basis,
            n_atoms=n_dof//3,
            n_states=n_states,
            rasscf=rasscf,
            cartesian_coo="{cartesian_coo}")

    def _calculate_adiabatic_all(self, R, P, S=0):
        # TODO Take the current state in account
        full_output = self._run_molcas(R)

        # Parse the energy of each RASSCF root
        energies = PATTERNS["energy"].findall(full_output)
        self._adiabatic_energy[:, 0] = np.array([float(E) for E in energies])

        # Parse the molecular gradient at each nucleus
        gradient_section, = PATTERNS["gradient section"].findall(full_output)
        gradients = PATTERNS["molecular vector"].findall(gradient_section)
        self._adiabatic_gradient[S, :, 0] = np.concatenate(
            [np.fromstring(grad, sep=" ") for grad in gradients])

        # Parse the NAC for each pair of states
        nac_sections = PATTERNS["nac section"].findall(full_output)
        section_num = 0

        for i in range(self.n_states):
            for j in range(i):
                nac_section = nac_sections[section_num]
                matched_vec = PATTERNS["molecular vector"].findall(nac_section)
                nac_vector = np.concatenate(
                    [np.fromstring(v, sep=" ") for v in matched_vec])

                self._nac[i, j, :, 0] = nac_vector
                self._nac[j, i, :, 0] = -nac_vector

                section_num += 1

    def _molcas_subprocess(self, *args):
        """
        Start MOLCAS as a subprocess and return its output as a string.

        Ignore MOLCAS rc file and use a minimal environnement containing only
        the PATH variable and MOLCAS related shell variables build based on
        the content of the input file.

        Parameters
        ----------
        *args : All parameters must be strings and are passed as additional
            parameters to the MOLCAS program.
        """
        res = subprocess.run(
            [self._molcas_executable, "-ign", *args],
            env=self._molcas_env,  # Define environnement variables
            text=True,  # Everything treated as string rather than binary
            stdout=subprocess.PIPE)  # Redirect output to the returned object

        # Raise an error if something wrong happened within MOLCAS
        if res.returncode != 0:
            raise MolcasError(res.stdout)

        return res.stdout

    def _run_molcas(self, R):
        """
        Run MOLCAS for a given configuration.
        """
        input_str = self._template_molcas_input.format(xcart=R)
        self._molcas_input_file.write_text(input_str)

        # NOTE Currently self._compute_from_scratch is always True
        if self._compute_from_scratch:
            self._molcas_env["MOLCAS_NEW_WORKDIR"] = "YES"
        else:
            self._molcas_env["MOLCAS_NEW_WORKDIR"] = "NO"

        return self._molcas_subprocess(self._molcas_input_file)

    def _test_molcas(self):
        """
        Test that the molcas executable name exists and determine its MOLCAS
        version.
        """
        empty_input = Path(__file__).with_name("empty.input")
        try:
            # Run molcas with empty input file to only have base output
            output = self._molcas_subprocess(empty_input)
        except FileNotFoundError:
            raise FileNotFoundError(
                f"No MOLCAS executable named {self._molcas_executable} found. "
                "Make sure to add the executable to your PATH or to specify "
                "its full path in the input file.")

        self._molcas_version, = PATTERNS["molcas version"].findall(output)

        print(f"MOLCAS version {self._molcas_version} is used.")

        # TODO check if the provided MOLCAS supports Alaska NAC e.g. using molcas help alaska nac
